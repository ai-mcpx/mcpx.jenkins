properties([
  parameters([
    [$class: 'io.modelcontextprotocol.jenkins.parameters.McpxServerParameterDefinition', name: 'MCP_SERVER', description: 'Select an MCP server', defaultServer: '']
    // Package parameters are automatically available as environment variables when MCP_SERVER is set
    // They are extracted from the server's packages configuration (registryType, runtimeArguments and environmentVariables)
    // Examples based on common package structures:
    // - Package metadata: MCPX_REGISTRY_TYPE (from registryType, e.g., docker, binary, npm, pypi, wheel)
    // - Named runtime arguments: MCPX_PORT, MCPX_HOST, MCPX_CONFIG_PATH, MCPX_PORT_MAPPING (if valueHint is used)
    // - Positional runtime arguments: MCPX_PORT_MAPPING, MCPX_VOLUME_MAPPING, etc.
    // - Environment variables: MCPX_MCP_LOG_LEVEL, MCPX_MCP_DATA_DIR, MCPX_GERRIT_BASE_URL, etc.
    // You can optionally add them as String parameters to allow overriding in "Build with Parameters"
  ])
])

// Helper functions to get configuration (using @NonCPS to bypass sandbox)
// Must be defined at top level, not inside script block
@NonCPS
def getJobCliPath() {
  try {
    def job = currentBuild.rawBuild.project
    def jobProperty = job.getProperty(io.modelcontextprotocol.jenkins.McpxJobProperty.class)
    if (jobProperty != null) {
      def path = jobProperty.getCliPath()
      return (path != null && path.trim() != '') ? path.trim() : null
    }
    return null
  } catch (Exception e) {
    return null
  }
}

@NonCPS
def getGlobalCliPath() {
  try {
    def globalConfig = io.modelcontextprotocol.jenkins.McpxGlobalConfiguration.get()
    if (globalConfig != null) {
      def path = globalConfig.getCliPath()
      return (path != null && path.trim() != '') ? path.trim() : null
    }
    return null
  } catch (Exception e) {
    return null
  }
}

@NonCPS
def getJobRegistryBaseUrl() {
  try {
    def job = currentBuild.rawBuild.project
    def jobProperty = job.getProperty(io.modelcontextprotocol.jenkins.McpxJobProperty.class)
    if (jobProperty != null) {
      def url = jobProperty.getRegistryBaseUrl()
      return (url != null && url.trim() != '') ? url.trim() : null
    }
    return null
  } catch (Exception e) {
    return null
  }
}

@NonCPS
def getGlobalRegistryBaseUrl() {
  try {
    def globalConfig = io.modelcontextprotocol.jenkins.McpxGlobalConfiguration.get()
    if (globalConfig != null) {
      def url = globalConfig.getRegistryBaseUrl()
      return (url != null && url.trim() != '') ? url.trim() : null
    }
    return null
  } catch (org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException e) {
    // Script security sandbox is blocking access to global configuration
    // This will be logged and fallback will be used
    return null
  } catch (java.lang.SecurityException e) {
    // Security exception when accessing global configuration
    return null
  } catch (Exception e) {
    // Any other exception
    return null
  }
}

pipeline {
  agent {
    label 'mcpx.jenkins'
  }
  environment {
    MCPX_CLI_PATH = '/home/lemonjia/.local/bin/mcpx-cli'
    MCPX_REGISTRY_BASE_URL = 'https://mcpx.example.com'
  }
  stages {
    stage('Show MCP Server') {
      steps {
        echo "Selected MCP server: ${env.MCP_SERVER}"
      }
    }
    stage('Show Package Parameters') {
      steps {
        script {
          echo "=== Package Parameters from MCP Server ==="
          echo "MCP_SERVER: ${env.MCP_SERVER ?: 'Not set'}"

          // Runtime arguments (named) - examples from common package structures
          if (env.MCPX_PORT) {
            echo "MCPX_PORT: ${env.MCPX_PORT}"
          }
          if (env.MCPX_HOST) {
            echo "MCPX_HOST: ${env.MCPX_HOST}"
          }
          if (env.MCPX_CONFIG_PATH) {
            echo "MCPX_CONFIG_PATH: ${env.MCPX_CONFIG_PATH}"
          }
          if (env.MCPX_PORT_MAPPING) {
            echo "MCPX_PORT_MAPPING: ${env.MCPX_PORT_MAPPING}"
          }
          if (env.MCPX_HOST_ADDRESS) {
            echo "MCPX_HOST_ADDRESS: ${env.MCPX_HOST_ADDRESS}"
          }
          if (env.MCPX_PORT_NUMBER) {
            echo "MCPX_PORT_NUMBER: ${env.MCPX_PORT_NUMBER}"
          }

          // Runtime arguments (positional)
          if (env.MCPX_VOLUME_MAPPING) {
            echo "MCPX_VOLUME_MAPPING: ${env.MCPX_VOLUME_MAPPING}"
          }
          if (env.MCPX_NETWORK_MODE) {
            echo "MCPX_NETWORK_MODE: ${env.MCPX_NETWORK_MODE}"
          }

          // Environment variables
          if (env.MCPX_MCP_LOG_LEVEL) {
            echo "MCPX_MCP_LOG_LEVEL: ${env.MCPX_MCP_LOG_LEVEL}"
          }
          if (env.MCPX_MCP_DATA_DIR) {
            echo "MCPX_MCP_DATA_DIR: ${env.MCPX_MCP_DATA_DIR}"
          }
          if (env.MCPX_MCP_HOST) {
            echo "MCPX_MCP_HOST: ${env.MCPX_MCP_HOST}"
          }
          if (env.MCPX_MCP_PORT) {
            echo "MCPX_MCP_PORT: ${env.MCPX_MCP_PORT}"
          }
          if (env.MCPX_GERRIT_BASE_URL) {
            echo "MCPX_GERRIT_BASE_URL: ${env.MCPX_GERRIT_BASE_URL}"
          }

          // Package metadata
          if (env.MCPX_REGISTRY_TYPE) {
            echo "MCPX_REGISTRY_TYPE: ${env.MCPX_REGISTRY_TYPE}"
          }

          echo "=== All MCPX_* Environment Variables ==="
          sh '''
            env | grep "^MCPX_" | sort || echo "No MCPX_* environment variables found"
          '''
        }
      }
    }
    stage('Run MCP Server') {
      when {
        expression { env.MCP_SERVER != null && env.MCP_SERVER != '' }
      }
      steps {
        script {
          def registryType = env.MCPX_REGISTRY_TYPE ?: 'unknown'
          echo "Running MCP server: ${env.MCP_SERVER}"
          echo "Registry type: ${registryType}"

          // Get server details to extract package information
          // Get CLI path from job-level or global configuration
          // Priority: environment variable > job-level > global > default
          // Note: If @NonCPS functions are blocked by sandbox, use MCPX_CLI_PATH environment variable
          def mcpxCliPath = null

          // First check environment variable (works even if @NonCPS is blocked)
          if (env.MCPX_CLI_PATH != null && env.MCPX_CLI_PATH.trim() != '') {
            mcpxCliPath = env.MCPX_CLI_PATH.trim()
            echo "Using CLI path from MCPX_CLI_PATH environment variable: ${mcpxCliPath}"
          } else {
            // Try to get from configuration (may be blocked by sandbox)
            def jobCliPath = getJobCliPath()
            def globalCliPath = getGlobalCliPath()

            // Get CLI path (job-level overrides global configuration)
            if (jobCliPath != null) {
              mcpxCliPath = jobCliPath
              echo "Using job-level CLI path: ${mcpxCliPath}"
            } else if (globalCliPath != null) {
              mcpxCliPath = globalCliPath
              echo "Using global CLI path: ${mcpxCliPath}"
            }
          }

          if (mcpxCliPath == null) {
            mcpxCliPath = 'mcpx-cli' // fallback default
            echo "Using fallback CLI path: ${mcpxCliPath}"
            echo "Note: Configuration access may be blocked by script security sandbox."
            echo "      To fix, either:"
            echo "      1. Set MCPX_CLI_PATH environment variable in job configuration (e.g., /home/lemonjia/.local/bin/mcpx-cli)"
            echo "      2. Approve script security for getRawBuild and McpxGlobalConfiguration.get in Manage Jenkins → In-process Script Approval"
          }

          // Get base URL from job-level or global configuration
          // Priority: job-level > global > environment variable > default
          // Use @NonCPS helper functions to get values directly (bypasses sandbox)
          def jobBaseUrl = getJobRegistryBaseUrl()
          def globalBaseUrl = getGlobalRegistryBaseUrl()

          def baseUrl = null
          if (jobBaseUrl != null) {
            baseUrl = jobBaseUrl
            echo "Using job-level registry base URL: ${baseUrl}"
          } else if (globalBaseUrl != null) {
            baseUrl = globalBaseUrl
            echo "Using global registry base URL: ${baseUrl}"
          } else if (env.MCPX_REGISTRY_BASE_URL != null && env.MCPX_REGISTRY_BASE_URL.trim() != '') {
            baseUrl = env.MCPX_REGISTRY_BASE_URL.trim()
            echo "Using registry base URL from MCPX_REGISTRY_BASE_URL environment variable: ${baseUrl}"
          } else {
            baseUrl = 'https://registry.modelcontextprotocol.io'
            echo "WARNING: Using default registry base URL: ${baseUrl}"
            echo "Note: Global configuration access may be blocked by script security sandbox."
            echo "      To use your configured 'Registry Base URL' from Global Configuration, either:"
            echo "      1. Set MCPX_REGISTRY_BASE_URL environment variable in job configuration"
            echo "      2. Approve script security for McpxGlobalConfiguration.get in Manage Jenkins → In-process Script Approval"
          }

          echo "Using CLI path: ${mcpxCliPath}"
          echo "Using base URL: ${baseUrl}"

          // Fetch server details to get package identifier
          def serverJson = sh(
            script: "${mcpxCliPath} --base-url=${baseUrl} server ${env.MCP_SERVER} --json",
            returnStdout: true
          ).trim()

          // Parse JSON using Groovy's JsonSlurper (built-in, no plugin required)
          def serverData = new groovy.json.JsonSlurper().parseText(serverJson)

          def packageInfo = null
          if (serverData.packages && serverData.packages.size() > 0) {
            // Try to find package matching registry type
            packageInfo = serverData.packages.find { pkg ->
              pkg.registryType == registryType
            }
            // If not found, use first package
            if (!packageInfo) {
              packageInfo = serverData.packages[0]
            }
          }

          if (!packageInfo) {
            error("No package found in server configuration. Expected registry type: ${registryType}, but server has no packages.")
          }

          echo "Package identifier: ${packageInfo.identifier}"
          echo "Package version: ${packageInfo.version}"

          // Build command based on registry type
          def cmd = []
          def envVars = [:]

          // Extract environment variables from package config
          // These are variables that should be passed as environment variables to the command
          def packageEnvVars = packageInfo.environmentVariables ?: []
          packageEnvVars.each { envVar ->
            def envVarName = envVar.name
            def mcpxEnvVarName = "MCPX_${envVarName}"
            if (env[mcpxEnvVarName]) {
              envVars[envVarName] = env[mcpxEnvVarName]
            } else if (envVar.default) {
              envVars[envVarName] = envVar.default
            }
          }

          // Build runtime arguments map from package config and env vars
          def runtimeArgs = [:]
          def positionalArgs = []
          def dockerSpecialArgs = [:] // For docker-specific positional args that map to flags

          packageInfo.runtimeArguments?.each { arg ->
            def argValue = null
            if (arg.type == 'named') {
              // Named argument: check for valueHint or use name
              if (arg.valueHint) {
                def envKey = "MCPX_${arg.valueHint.toUpperCase().replaceAll('-', '_')}"
                argValue = env[envKey] ?: arg.default
              } else {
                // Use argument name without leading dashes
                def argName = arg.name.replaceAll(/^--?/, '').replaceAll(/-/, '_').toUpperCase()
                def envKey = "MCPX_${argName}"
                argValue = env[envKey] ?: arg.default
              }

              // For flags without values (like --rm), just check if they should be included
              if (arg.isRequired && !arg.valueHint && arg.name == '--rm') {
                runtimeArgs['--rm'] = true
              } else if (argValue) {
                runtimeArgs[arg.name] = argValue
              }
            } else if (arg.type == 'positional') {
              // Positional argument: use valueHint
              def envKey = "MCPX_${arg.valueHint.toUpperCase().replaceAll('-', '_')}"
              def value = env[envKey] ?: arg.default
              if (value) {
                // For docker, some positional args map to docker flags
                if (registryType == 'docker') {
                  if (arg.valueHint == 'port_mapping') {
                    dockerSpecialArgs['-p'] = value
                  } else if (arg.valueHint == 'volume_mapping') {
                    dockerSpecialArgs['-v'] = value
                  } else if (arg.valueHint == 'network_mode') {
                    dockerSpecialArgs['--network'] = value
                  } else {
                    positionalArgs << value
                  }
                } else {
                  positionalArgs << value
                }
              }
            }
          }

          switch(registryType) {
            case 'docker':
              cmd = ['docker', 'run']

              // Add named arguments
              runtimeArgs.each { argName, argValue ->
                if (argName == '--rm' && argValue == true) {
                  cmd << '--rm'
                } else if (argName == '-p' || argName == '--publish') {
                  cmd << '-p' << argValue.toString()
                } else if (argName == '-v' || argName == '--volume') {
                  cmd << '-v' << argValue.toString()
                } else if (argName == '--network') {
                  cmd << '--network' << argValue.toString()
                } else if (argValue != true) {
                  // Other named arguments
                  cmd << argName << argValue.toString()
                }
              }

              // Add docker-specific special args (from positional with valueHint)
              dockerSpecialArgs.each { flag, value ->
                cmd << flag << value
              }

              // Add environment variables
              envVars.each { key, value ->
                cmd << '-e' << "${key}=${value}"
              }

              // Add image identifier
              def imageTag = "${packageInfo.identifier}:${packageInfo.version}"
              cmd << imageTag

              // Add remaining positional arguments (after image name)
              positionalArgs.each { posArg ->
                cmd << posArg
              }

              break

            case 'binary':
              // Binary execution
              cmd = [packageInfo.identifier]

              // Add named arguments
              runtimeArgs.each { argName, argValue ->
                if (argValue != true) {
                  cmd << argName << argValue.toString()
                } else {
                  cmd << argName
                }
              }

              // Add positional arguments
              positionalArgs.each { posArg ->
                cmd << posArg
              }

              break

            case 'npm':
              // npm/npx execution
              cmd = ['npx', packageInfo.identifier]

              // Add named arguments
              runtimeArgs.each { argName, argValue ->
                if (argValue != true) {
                  cmd << argName << argValue.toString()
                } else {
                  cmd << argName
                }
              }

              // Add positional arguments
              positionalArgs.each { posArg ->
                cmd << posArg
              }

              break

            case 'pypi':
            case 'wheel':
              // Python execution
              if (registryType == 'pypi') {
                cmd = ['python', '-m', packageInfo.identifier]
              } else {
                // For wheel, extract module name from identifier
                def moduleName = packageInfo.identifier
                if (moduleName.contains('/')) {
                  moduleName = moduleName.substring(moduleName.lastIndexOf('/') + 1)
                }
                moduleName = moduleName.replaceAll(/\.whl$/, '').replaceAll(/-.*$/, '')
                cmd = ['python', '-m', moduleName]
              }

              // Add named arguments
              runtimeArgs.each { argName, argValue ->
                if (argValue != true) {
                  cmd << argName << argValue.toString()
                } else {
                  cmd << argName
                }
              }

              // Add positional arguments
              positionalArgs.each { posArg ->
                cmd << posArg
              }

              break

            default:
              error("Unsupported registry type: ${registryType}")
          }

          echo "Executing command: ${cmd.join(' ')}"
          if (envVars) {
            echo "Environment variables: ${envVars.collect { k, v -> "${k}=${v}" }.join(', ')}"
          }

          // Execute with environment variables
          def envString = envVars.collect { k, v -> "${k}=${v}" }.join(' ')
          if (envString) {
            sh "${envString} ${cmd.join(' ')}"
          } else {
            sh cmd.join(' ')
          }
        }
      }
    }
  }
}
